# angrとは

angrはマルチアーキテクチャ対応のバイナリ解析プラットフォームです．動的シンボリック実行（MeyhemやKLEEのような）や多種多様な静的解析の機能を備えています．これを実現するためには，いくつかの技術的課題を克服しなければなりません．大まかに言えば：

- 解析プログラムにバイナリをロードする．
- バイナリを中間表現 (IR) に変換する．
- IRを意味表現に変換する（言い換えれば，それが何で*ある*かだけでなく，何を*行う*か）．
- バイナリを実際に解析する．これはたとえば：
 - プログラムの部分または全体の静的解析（言い換えれば，依存解析，プログラムスライシング）．
 - プログラムの状態空間に対するシンボリック探索（言い換えれば，「オーバーフローを見つけるまでプログラムを実行できるか？」）
 - 上記の組合せ（言い換えれば，「オーバーフローを見つけるために，メモリ書き込みに関するプログラムスライスだけを実行してみよう」）．

angrはこれらの技術的課題に対応するコンポーネント群を擁しています．
本書は，それぞれのコンポーネントがどのように動作し，どのようにあなたの悪だくみに貢献するか解説します．

## バイナリのロード

angrのインストールが済めば，解析対象のバイナリをロードできるようになります．
このプロセス，そしてそれを提供するangrのコンポーネント（CLEと呼ばれます）は[こちら](./loading.md)で解説されています．

## 中間表現

angrは中間表現（具体的にはVEX）を用いて異なるアーキテクチャのバイナリを解析できるようにします．
このIRは[こちら](./ir.md)で解説されています．

## ソルバエンジン

制約充足問題の解決やその他の演算処理は，Claripyと呼ばれるangrのサブモジュールによって提供されています．
ほとんどのangrユーザーは，Claripyについて知る必要はありませんが，必要に備えてドキュメントが提供されています．
Claripyの詳しい説明は[こちら](./claripy.md)．

## プログラムの状態

angrはエミュレートされたマシンの状態へのインターフェイスを提供しています．
angrを正しく扱うためには，これを理解することが重要です．詳しい説明は[こちら](./states.md)．

## プログラムのパス

プログラムは，実行に沿う*パス*単位で解析することができます．
angrは各パスが何を実行し，*行う*か暴きます．
[本章](./paths.md)では，angrのパス解析機能の利用法を紹介します．

## 意味表現

angrの強力な機能は，プログラムの状態に与える影響という観点で基本ブロックを表現する能力です．
言い換えれば，angrは基本ブロックが何で*ある*かばかりでなく，何を*行う*か推論することができます．
[こちら](./simuvex.md).で解説されている，SimuVEXというモジュールがこれを成し遂げます．

## シンボリック実行

angrは優れたシンボリック実行エンジンを提供します．
このエンジンへのインターフェイス，そしてその使い方は[こちら](./surveyors.md)で解説されています．

## プログラム全体の解析

上記すべてのコンポーネントを団結させることで，angrは複雑な，プログラム全体にまたがった解析を簡単に進めることができます．
解析のメカニズムと，そのためのスクリプトの書き方は[こちら](./analyses.md)で解説されています．

# 実例

私たちはいくつかのangrの利用例を書きました！　[こちら](./examples.md)から読むことができます．
