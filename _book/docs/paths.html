
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <title>実行の制御 · GitBook</title>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.0.0">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="pathgroups.html" />
    
    
    <link rel="prev" href="simuvex.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    イントロダクション
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.1.1" data-path="overview.html">
            
                <a href="overview.html">
            
                    
                    概要
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.2" data-path="../INSTALL.html">
            
                <a href="../INSTALL.html">
            
                    
                    インストール
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.3" data-path="../HACKING.html">
            
                <a href="../HACKING.html">
            
                    
                    コントリビュートするには
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.4" data-path="../HELPWANTED.html">
            
                <a href="../HELPWANTED.html">
            
                    
                    コントリビュートの対象
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="toplevel.html">
            
                <a href="toplevel.html">
            
                    
                    トップレベルインターフェイス
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="loading.html">
            
                <a href="loading.html">
            
                    
                    バイナリのロード
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="ir.html">
            
                <a href="ir.html">
            
                    
                    中間表現
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="claripy.html">
            
                <a href="claripy.html">
            
                    
                    ソルバエンジン
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="states.html">
            
                <a href="states.html">
            
                    
                    プログラムの状態管理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="symbolic.html">
            
                <a href="symbolic.html">
            
                    
                    シンボリック実行
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.1" data-path="simuvex.html">
            
                <a href="simuvex.html">
            
                    
                    実行エンジン
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.7.2" data-path="paths.html">
            
                <a href="paths.html">
            
                    
                    実行の制御
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.3" data-path="pathgroups.html">
            
                <a href="pathgroups.html">
            
                    
                    バルク実行 - パスグループ
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4" data-path="surveyors.html">
            
                <a href="surveyors.html">
            
                    
                    バルク実行 - サーベイヤー
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="structured_data.html">
            
                <a href="structured_data.html">
            
                    
                    データ型と呼び出し規約を扱う
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="analyses.html">
            
                <a href="analyses.html">
            
                    
                    解析
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.9.1" data-path="analyses/cfg_accurate.html">
            
                <a href="analyses/cfg_accurate.html">
            
                    
                    CFGAccurate
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2" data-path="analyses/backward_slice.html">
            
                <a href="analyses/backward_slice.html">
            
                    
                    バックワードスライス
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="speed.html">
            
                <a href="speed.html">
            
                    
                    高速化のてびき
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="examples.html">
            
                <a href="examples.html">
            
                    
                    実例
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="faq.html">
            
                <a href="faq.html">
            
                    
                    FAQ
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13" data-path="gotchas.html">
            
                <a href="gotchas.html">
            
                    
                    問題点
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14" data-path="../CHANGELOG.html">
            
                <a href="../CHANGELOG.html">
            
                    
                    更新履歴
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >実行の制御</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="program-paths---controlling-execution">Program Paths - Controlling Execution</h1>
<p>SimuVEX provides an incredibly awkward interface for performing symbolic execution. Paths are angr&apos;s primary interface to provide an abstraction to control execution, and are used in most interactions with angr and its analyses.</p>
<p>A path through a program is, at its core, a sequence of basic blocks (actually, SimRuns) representing what was executed since the program started.
These blocks in the paths can repeat (in the case of loops) and a program can have a near-infinite amount of paths (for example, a program with a single branch will have two paths, a program with two branches nested within each other will have 4, and so on).</p>
<p>To create an empty path at the program&apos;s entry point, do:</p>
<pre><code class="lang-python"><span class="hljs-comment"># load a binary</span>

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> angr
<span class="hljs-meta">&gt;&gt;&gt; </span>b = angr.Project(<span class="hljs-string">&apos;/bin/true&apos;</span>)

<span class="hljs-comment"># load the path</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>p = b.factory.path()

<span class="hljs-comment"># this is the address that the path is *about to* execute</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">assert</span> p.addr == b.entry
</code></pre>
<p>After this, <code>p</code> is a path representing the program at the entry point.
We can see that the callstack and the path&apos;s history are blank:</p>
<pre><code class="lang-python"><span class="hljs-comment"># this is the number of basic blocks that have been analyzed by the path</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">assert</span> p.length == <span class="hljs-number">0</span>

<span class="hljs-comment"># we can also look at the current backtrace of program execution</span>
<span class="hljs-comment"># contains only the dummy frame for execution start</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">assert</span> len(p.callstack) == <span class="hljs-number">1</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">print</span> p.callstack
Backtrace:
Func <span class="hljs-number">0x401410</span>, sp=<span class="hljs-number">0x7fffffffffeffd8</span>, ret=<span class="hljs-number">0x0</span>
</code></pre>
<h2 id="moving-forward">Moving Forward</h2>
<p>Of course, we can&apos;t be stuck at the entry point forever. call <code>p.step()</code> to run the single block of symbolic execution.
We can look at the <code>successors</code> of a path to see where the program goes after this point. <code>p.step()</code> also returns the successors if you&apos;d like to chain calls.
Most of the time, a path will have one or two successors. When there are two successors, it usually means the program branched and there are two possible ways forward with execution. Other times, it will have more than two, such as in the case of a jump table.</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>p.step()
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;The path has&quot;</span>, len(p.successors), <span class="hljs-string">&quot;successors!&quot;</span>

<span class="hljs-comment"># each successor is a path, keeping track of an execution history</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>s = p.successors[<span class="hljs-number">0</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">assert</span> s.addr_trace[<span class="hljs-number">-1</span>] == p.addr

<span class="hljs-comment"># and, of course, we can drill down further!</span>
<span class="hljs-comment"># alternate syntax: s.step() returns the same list as s.successors</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>ss = s.step()[<span class="hljs-number">0</span>].step()[<span class="hljs-number">0</span>].step()[<span class="hljs-number">0</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>len(ss.addr_trace.hardcopy) == <span class="hljs-number">4</span>
</code></pre>
<p>To efficiently store information about path histories, angr employs a tree structure that resembles the actual symbolic execution tree.
You should never have to worry about this, since through the magic of python we provide efficient accessors for information stored in the tree as it pertains to each stored historical property.
The one thing you have to know is that this data structure doesn&apos;t allow efficient iteration through the historical lists in forward order - only in reverse order, from most recent to oldest.
If you need to iterate or access items from these sequences starting from the beginning, you may access the <code>.hardcopy</code> property on them, which will extract the entirety of the property&apos;s history as a flat list for you to peruse at leisure.</p>
<p>For example: part of the history of a path is the <em>types</em> of jumps that occur.
These are stored (as strings representing VEX exit type enums), in the <code>jumpkinds</code> attribute.</p>
<pre><code class="lang-python"><span class="hljs-comment"># recall: s is the path created when we stepped forward the initial path once</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">print</span> s.jumpkinds
&lt;angr.path.JumpkindIter object at <span class="hljs-number">0x7f8161e584d0</span>&gt;

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">assert</span> s.jumpkinds[<span class="hljs-number">-1</span>] == <span class="hljs-string">&apos;Ijk_Call&apos;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">print</span> s.jumpkinds.hardcopy
[<span class="hljs-string">&apos;Ijk_Call&apos;</span>]

<span class="hljs-comment"># Don&apos;t do this! This will throw an exception</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># for jk in ss.jumpkinds: print jk</span>

<span class="hljs-comment"># Do this instead:</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> jk <span class="hljs-keyword">in</span> reversed(ss.jumpkinds): <span class="hljs-keyword">print</span> jk
Ijk_Call
Ijk_Call
Ijk_Boring
Ijk_Call

<span class="hljs-comment"># Or, if you really need to iterate in forward order:</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> jk <span class="hljs-keyword">in</span> ss.jumpkinds.hardcopy: <span class="hljs-keyword">print</span> jk
Ijk_Call
Ijk_Boring
Ijk_Call
Ijk_Call
</code></pre>
<p>Here is a list of the properties in the path history:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Path.addr_trace</td>
<td>The addresses of basic blocks that have been executed so far, as integers</td>
</tr>
<tr>
<td>Path.trace</td>
<td>The SimRun objects that have been executed so far, as strings</td>
</tr>
<tr>
<td>Path.targets</td>
<td>The targets of the jumps/successors that have been taken so far</td>
</tr>
<tr>
<td>Path.guards</td>
<td>The guard conditions that had to be satisfied in order to take the branch listed in Path.targets</td>
</tr>
<tr>
<td>Path.jumpkinds</td>
<td>The type of the exit from each basic block we took, as VEX struct strings</td>
</tr>
<tr>
<td>Path.events</td>
<td>A log of the events that have happened in symbolic execution</td>
</tr>
<tr>
<td>Path.actions</td>
<td>A filtering of Path.events to only include the actions taken by the exeution engine. See below.</td>
</tr>
</tbody>
</table>
<p>Here are the different types of jumpkinds:</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ijk_Boring</td>
<td>A normal jump to an address.</td>
</tr>
<tr>
<td>Ijk_Call</td>
<td>A call to an address.</td>
</tr>
<tr>
<td>Ijk_Ret</td>
<td>A return.</td>
</tr>
<tr>
<td>Ijk_Sig*</td>
<td>Various signals.</td>
</tr>
<tr>
<td>Ijk_Sys*</td>
<td>System calls.</td>
</tr>
<tr>
<td>Ijk_NoHook</td>
<td>A jump out of an angr hook.</td>
</tr>
</tbody>
</table>
<h2 id="merging-paths">Merging Paths</h2>
<p>Like states, paths can be merged.
Truly understanding this requires concepts that will be explained in future sections, but in a nutshell, we can combine two paths that reached the same program point in different ways.
For example, let&apos;s say that we have a branch:</p>
<pre><code class="lang-python"><span class="hljs-comment"># step until branch</span>
p = b.factory.path()
p.step()
<span class="hljs-keyword">while</span> len(p.successors) == <span class="hljs-number">1</span>:
    <span class="hljs-keyword">print</span> <span class="hljs-string">&apos;step&apos;</span>
    p = p.successors[<span class="hljs-number">0</span>]
    p.step()

<span class="hljs-keyword">print</span> p
branched_left = p.successors[<span class="hljs-number">0</span>]
branched_right = p.successors[<span class="hljs-number">1</span>]
<span class="hljs-keyword">assert</span> branched_left.addr != branched_right.addr

<span class="hljs-comment"># Step the branches until they converge again</span>
after_branched_left = branched_left.step()[<span class="hljs-number">0</span>]
after_branched_right = branched_right.step()[<span class="hljs-number">0</span>]
<span class="hljs-keyword">assert</span> after_branched_left.addr == after_branched_right.addr

<span class="hljs-comment"># this will merge both branches into a single path. Values in memory and registers</span>
<span class="hljs-comment"># will hold any possible values they could have held in either path.</span>
merged = after_branched_left.merge(after_branched_right)
<span class="hljs-keyword">assert</span> merged.addr == after_branched_left.addr <span class="hljs-keyword">and</span> merged.addr == after_branched_right.addr
</code></pre>
<p>Paths can also be unmerged later.</p>
<pre><code class="lang-python">merged_successor = merged.step()[<span class="hljs-number">0</span>].step()[<span class="hljs-number">0</span>]
unmerged_paths = merged_successor.unmerge()

<span class="hljs-keyword">assert</span> len(unmerged_paths) == <span class="hljs-number">2</span>
<span class="hljs-keyword">assert</span> unmerged_paths[<span class="hljs-number">0</span>].addr == unmerged_paths[<span class="hljs-number">1</span>].addr
</code></pre>
<h2 id="non-entry-point-start">Non-entry point start</h2>
<p>Sometimes, you might want to start the analysis of a program partway through the program.
For example, you might be interested in what a specific part of a function does, but don&apos;t know how to (or don&apos;t want to) guide a path to that point.
To handle this, we allow the creation of a path at any point in the program:</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>st = b.factory.blank_state(addr=<span class="hljs-number">0x800f000</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>p = b.factory.path(st)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">assert</span> p.addr == <span class="hljs-number">0x800f000</span>
</code></pre>
<p>At this point, all memory, registers, and so forth of the path are blank. In a nutshell, this means that they are fully symbolic and unconstrained, and execution can procede from this point as an overapproximation of what could happen on a real CPU. If you have outside knowledge about what the state should look like at this point, you can craft the blank state into a more precise description of machine state by adding constraints and setting the contents of memory, registers, and files.</p>
<h2 id="simactions-redux">SimActions Redux</h2>
<p>The SimActions from deep within simuvex are exported for much easier access through the Path. Actions are part of the path&apos;s history (Path.actions), so the same rules as the other history items about iterating over them still apply. The actions are a flat list here, instead of the per-statement way they&apos;re present in SimIRSBs.</p>
<p>When paths grow long, stored SimActions can be a serious source of memory consumption. Because of this, by default all but the most recent SimActions are discarded. To disable this behavior, enable the <code>TRACK_ACTION_HISTORY</code> state option.</p>
<p>There is a convenient interface for filtering through a potentially huge list of actions to find a specific write or read operation. Take a look at the <a href="http://angr.io/api-doc/angr.html#angr.path.Path.filter_actions" _target="blank">api documentation for Path.filter_actions</a>.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="simuvex.html" class="navigation navigation-prev " aria-label="Previous page: 実行エンジン">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="pathgroups.html" class="navigation navigation-next " aria-label="Next page: バルク実行 - パスグループ">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"実行の制御","level":"1.7.2","depth":2,"next":{"title":"バルク実行 - パスグループ","level":"1.7.3","depth":2,"path":"docs/pathgroups.md","ref":"docs/pathgroups.md","articles":[]},"previous":{"title":"実行エンジン","level":"1.7.1","depth":2,"path":"docs/simuvex.md","ref":"docs/simuvex.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"docs/paths.md","mtime":"2016-09-25T13:21:13.655Z","type":"markdown"},"gitbook":{"version":"3.0.0","time":"2016-09-28T03:18:21.902Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/buttons.js"></script>
        
    

    </body>
</html>

