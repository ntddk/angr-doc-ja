
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <title>バイナリのロード · GitBook</title>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.0.0">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="ir.html" />
    
    
    <link rel="prev" href="toplevel.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    イントロダクション
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.1.1" data-path="overview.html">
            
                <a href="overview.html">
            
                    
                    概要
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.2" data-path="../INSTALL.html">
            
                <a href="../INSTALL.html">
            
                    
                    インストール
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.3" data-path="../HACKING.html">
            
                <a href="../HACKING.html">
            
                    
                    コントリビュートするには
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.4" data-path="../HELPWANTED.html">
            
                <a href="../HELPWANTED.html">
            
                    
                    コントリビュートの対象
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="toplevel.html">
            
                <a href="toplevel.html">
            
                    
                    トップレベルインターフェイス
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.3" data-path="loading.html">
            
                <a href="loading.html">
            
                    
                    バイナリのロード
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="ir.html">
            
                <a href="ir.html">
            
                    
                    中間表現
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="claripy.html">
            
                <a href="claripy.html">
            
                    
                    ソルバエンジン
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="states.html">
            
                <a href="states.html">
            
                    
                    プログラムの状態管理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="symbolic.html">
            
                <a href="symbolic.html">
            
                    
                    シンボリック実行
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.1" data-path="simuvex.html">
            
                <a href="simuvex.html">
            
                    
                    実行エンジン
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.2" data-path="paths.html">
            
                <a href="paths.html">
            
                    
                    実行の制御
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.3" data-path="pathgroups.html">
            
                <a href="pathgroups.html">
            
                    
                    バルク実行 - パスグループ
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4" data-path="surveyors.html">
            
                <a href="surveyors.html">
            
                    
                    バルク実行 - サーベイヤー
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="structured_data.html">
            
                <a href="structured_data.html">
            
                    
                    データ型と呼び出し規約を扱う
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="analyses.html">
            
                <a href="analyses.html">
            
                    
                    解析
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.9.1" data-path="analyses/cfg_accurate.html">
            
                <a href="analyses/cfg_accurate.html">
            
                    
                    CFGAccurate
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2" data-path="analyses/backward_slice.html">
            
                <a href="analyses/backward_slice.html">
            
                    
                    バックワードスライス
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="speed.html">
            
                <a href="speed.html">
            
                    
                    高速化のてびき
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="examples.html">
            
                <a href="examples.html">
            
                    
                    実例
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="faq.html">
            
                <a href="faq.html">
            
                    
                    FAQ
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13" data-path="gotchas.html">
            
                <a href="gotchas.html">
            
                    
                    問題点
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14" data-path="../CHANGELOG.html">
            
                <a href="../CHANGELOG.html">
            
                    
                    更新履歴
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >バイナリのロード</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="loading-a-binary---cle-and-angr-projects">Loading a Binary - CLE and angr Projects</h1>
<p>angr&apos;s binary loading component is CLE, which stands for CLE Loads Everything. CLE is responsible for taking a binary (and any libraries that it depends on) and presenting it to the rest of angr in a way that is easy to work with.</p>
<p>CLE&apos;s main goal is to load binaries in a robust way, i.e., the same way the actual loader (e.g., GNU LD in the case of ELF binaries) would load them. It means that some information that may be present in the binaries will be ignored by CLE, because such information may be stripped, voluntarily or involuntarily corrupted, etc.. It is not rare in the embedded world to see such things happening.</p>
<p>angr, in turn, encompasses this in a <em>Project</em> class. A Project class is the entity that represents your binary. Much of your interaction with angr will go through it.</p>
<p>To load a binary with angr (let&apos;s say &quot;/bin/true&quot;), you would do the following:</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> angr

<span class="hljs-meta">&gt;&gt;&gt; </span>b = angr.Project(<span class="hljs-string">&quot;/bin/true&quot;</span>)
</code></pre>
<p>After this, <em>b</em> is angr&apos;s representation of your binary (the &quot;main&quot; binary), along with any libraries that it depends on. There are several basic things that you can do here without further knowledge of the rest of the platform:</p>
<pre><code class="lang-python"><span class="hljs-comment"># this is the entry point of the binary</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">print</span> b.entry

<span class="hljs-comment"># these are the minimum and maximum addresses of the binary&apos;s memory contents</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">print</span> b.loader.min_addr(), b.loader.max_addr()

<span class="hljs-comment"># this is the full name of the binary</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">print</span> b.filename
</code></pre>
<p>CLE exposes the binary&apos;s information through the Loader class. The CLE loader (cle.Loader) represents an entire conglomerate of loaded CLE binary objects, loaded and mapped into a single memory space. Each binary object is loaded by a loader backend that can handle its filetype (a subclass of cle.Backend). For example, cle.ELF is used to load ELF binaries.</p>
<p>CLE can be interfaced with as follows:</p>
<pre><code class="lang-python"><span class="hljs-comment"># this is the CLE Loader object</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">print</span> b.loader

<span class="hljs-comment"># this is a dictionary of the objects that are loaded as part of loading the binary (their types depend on the backend)</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">print</span> b.loader.shared_objects

<span class="hljs-comment"># this is the memory space of the process after being loaded. It maps addresses to the byte at that address.</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">print</span> b.loader.memory[b.loader.min_addr()]

<span class="hljs-comment"># this is the object for the main binary (its type depends on the backend)</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">print</span> b.loader.main_bin

<span class="hljs-comment"># this retrieves the binary object which maps memory at the specified address</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">print</span> b.loader.addr_belongs_to_object(b.loader.max_addr())

<span class="hljs-comment"># Get the address of the GOT slot for a symbol (in the main binary)</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">print</span> b.loader.find_symbol_got_entry(<span class="hljs-string">&apos;__libc_start_main&apos;</span>)
</code></pre>
<p>It is also possible to interface directly with individual binary objects:</p>
<pre><code class="lang-python"><span class="hljs-comment"># this is a list of the names of libraries the program depend on. We obtain it</span>
<span class="hljs-comment"># *statically* by reading the DT_NEEDED field of the dynamic section of the Elf</span>
<span class="hljs-comment"># binary.</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">print</span> b.loader.main_bin.deps

<span class="hljs-comment"># this is a dict of the memory contents of *just* the main binary</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">print</span> b.loader.main_bin.memory

<span class="hljs-comment"># this is a dict (name-&gt;ELFRelocation) of imports required by the libc which was loaded</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>b.loader.shared_objects[<span class="hljs-string">&apos;libc.so.6&apos;</span>].imports

<span class="hljs-comment"># this is a dict (name-&gt;ELFRelocation) of imports of the main binary, where addr is usually 0 (see the misc section below).</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">print</span> b.loader.main_bin.imports
</code></pre>
<h2 id="loading-dependencies">Loading dependencies</h2>
<p>By default, CLE will attempt to load all the dependencies of the main binary (e.g., libc.so.6, ld-linux.so.2, etc.), unless <code>auto_load_libs</code> is set to <code>False</code> in the loading options. When loading libraries, if it cannot find one of them, it will silently ignore the error and mark all the dependencies on that library as unresolved. If you like, you can change this behavior.</p>
<h2 id="loading-options">Loading Options</h2>
<p>Loading options can be passed to Project (which in turn will pass it to CLE). </p>
<p>CLE expects a dict as a set of parameters. Parameters which must be applied to libraries which 
are not the target binary must be passed through the lib_opts parameter in the following form:</p>
<pre><code class="lang-python">load_options = {<span class="hljs-string">&apos;main_opts&apos;</span>:{options0}, <span class="hljs-string">&apos;lib_opts&apos;</span>: {libname1:{options1}, path2:{options2}, ...}}

<span class="hljs-comment"># Or in a more readable form:</span>
load_options = {}
load_options[<span class="hljs-string">&apos;main_opts&apos;</span>] = {k1:v1, k2:v2 ...}
load_options[<span class="hljs-string">&apos;lib_opts&apos;</span>] = {}
load_options[<span class="hljs-string">&apos;lib_opts&apos;</span>][path1] = {k1:v1, k2:v2, ...}
load_options[<span class="hljs-string">&apos;lib_opts&apos;</span>][path2] = {k1:v1, k2:v2, ...}
etc.
</code></pre>
<h3 id="valid-options">Valid options</h3>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>load_options = {}

<span class="hljs-comment"># shall we also load dynamic libraries?</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>load_options[<span class="hljs-string">&apos;auto_load_libs&apos;</span>] = <span class="hljs-keyword">False</span>

<span class="hljs-comment"># A list of libraries to load regardless of whether they&apos;re required by the loaded object</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>load_options[<span class="hljs-string">&apos;force_load_libs&apos;</span>] = [<span class="hljs-string">&apos;libleet.so&apos;</span>]

<span class="hljs-comment"># specific libs to skip</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>load_options[<span class="hljs-string">&apos;skip_libs&apos;</span>] = [<span class="hljs-string">&apos;libc.so.6&apos;</span>]

<span class="hljs-comment"># Options to be used when loading the main binary</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>load_options[<span class="hljs-string">&apos;main_opts&apos;</span>] = {<span class="hljs-string">&apos;backend&apos;</span>: <span class="hljs-string">&apos;elf&apos;</span>}

<span class="hljs-comment"># A dictionary mapping library names to a dictionary of objects to be used when loading them.</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>load_options[<span class="hljs-string">&apos;lib_opts&apos;</span>] = {<span class="hljs-string">&apos;libc.so.6&apos;</span>: {<span class="hljs-string">&apos;custom_base_addr&apos;</span>: <span class="hljs-number">0x13370000</span>}}

<span class="hljs-comment"># A list of paths we can additionally search for shared libraries</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>load_options[<span class="hljs-string">&apos;custom_ld_path&apos;</span>] = [<span class="hljs-string">&apos;/my/fav/libs&apos;</span>]

<span class="hljs-comment"># Whether libraries with different version numbers in the filename will be considered equivilant, for example libc.so.6 and libc.so.0</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>load_options[<span class="hljs-string">&apos;ignore_import_version_numbers&apos;</span>] = <span class="hljs-keyword">False</span>

<span class="hljs-comment"># The alignment to use for rebasing shared objects</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>load_options[<span class="hljs-string">&apos;rebase_granularity&apos;</span>] = <span class="hljs-number">0x1000</span>

<span class="hljs-comment"># Throw an Exception if a lib cannot be found (the default is fail silently on missing libs)</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>load_options[<span class="hljs-string">&apos;except_missing_libs&apos;</span>] = <span class="hljs-keyword">True</span>
</code></pre>
<p>The following options are applied on a per object basis and override CLE&apos;s automatic detection. 
They can be applied through either &apos;main_opts&apos; or &apos;lib_opts&apos;.</p>
<pre><code class="lang-python"><span class="hljs-comment"># Base address to load the binary</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>load_options[<span class="hljs-string">&apos;main_opts&apos;</span>] = {<span class="hljs-string">&apos;custom_base_addr&apos;</span>:<span class="hljs-number">0x4000</span>}

<span class="hljs-comment"># Specify the object&apos;s backend (backends discussed below)</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>load_options[<span class="hljs-string">&apos;main_opts&apos;</span>] = {<span class="hljs-string">&apos;backend&apos;</span>: <span class="hljs-string">&apos;elf&apos;</span>}
</code></pre>
<p>Example with multiple options for the same binary:</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>load_options[<span class="hljs-string">&apos;main_opts&apos;</span>] = {<span class="hljs-string">&apos;backend&apos;</span>:<span class="hljs-string">&apos;elf&apos;</span>, <span class="hljs-string">&apos;custom_base_addr&apos;</span>: <span class="hljs-number">0x10000</span>}
</code></pre>
<h2 id="backends">Backends</h2>
<p>CLE currently has backends for statically loading ELF, PE, CGC and ELF core dump files, as well as loading binaries with IDA and loading files into a flat address space. CLE will automatically detect the correct backend to use in most all cases, so you shouldn&apos;t need to specify which backend you&apos;re using unless you&apos;re doing some pretty weird stuff.</p>
<p>You can specify the backend for a binary by including a key in its options dictionary. If you need to force the architecture of a certain binary instead of having it auto-detected, you can specify it with the <code>custom_arch</code> key. The key doesn&apos;t need to match any list of arches; angr will identify which architecture you mean given almost any common identifier for any supported arch.</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>load_options = {}
<span class="hljs-meta">&gt;&gt;&gt; </span>load_options[<span class="hljs-string">&apos;main_opts&apos;</span>] = {<span class="hljs-string">&apos;backend&apos;</span>: <span class="hljs-string">&apos;elf&apos;</span>, <span class="hljs-string">&apos;custom_arch&apos;</span>: <span class="hljs-string">&apos;i386&apos;</span>}
<span class="hljs-meta">&gt;&gt;&gt; </span>load_options[<span class="hljs-string">&apos;lib_opts&apos;</span>] = {<span class="hljs-string">&apos;libc.so.6&apos;</span>: {<span class="hljs-string">&apos;backend&apos;</span>: <span class="hljs-string">&apos;elf&apos;</span>}}
</code></pre>
<table>
<thead>
<tr>
<th>backend key</th>
<th>description</th>
<th>requires <code>custom_arch</code>?</th>
</tr>
</thead>
<tbody>
<tr>
<td>elf</td>
<td>Static loader for ELF files based on PyELFTools</td>
<td>no</td>
</tr>
<tr>
<td>pe</td>
<td>Static loader for PE files based on PEFile</td>
<td>no</td>
</tr>
<tr>
<td>cgc</td>
<td>Static loader for Cyber Grand Challenge binaries</td>
<td>no</td>
</tr>
<tr>
<td>backedcgc</td>
<td>Static loader for CGC binaries that allows specifying memory and register backers</td>
<td>no</td>
</tr>
<tr>
<td>elfcore</td>
<td>Static loader for ELF core dumps</td>
<td>no</td>
</tr>
<tr>
<td>ida</td>
<td>Launches an instance of IDA to parse the file</td>
<td>yes</td>
</tr>
<tr>
<td>blob</td>
<td>Loads the file into memory as a flat image</td>
<td>yes</td>
</tr>
</tbody>
</table>
<p>Now that you have loaded a binary, interesting information about the binary is now accessible in <code>b.loader.main_bin</code>. For example, the shared library dependencies, the list of imported libraries, memory, symbols and others. 
Make heavy use of IPython&apos;s tab-completion to see available functions and options here.</p>
<p>Now it&apos;s time to look at the <a href="ir.html">IR support</a></p>
<h2 id="misc">Misc</h2>
<h3 id="imports">Imports</h3>
<p>The following is ELF specific.
On most architectures, imports, i.e., symbols that refer to functions or global names that are outside of the binary (in shared libraries) appear in the symbol table, most of the time with an undefined address (0). On some architectures like MIPS, it contains the address of the function&apos;s PLT stub (which resides in the text segment).
If you are looking for the address of the GOT entry related to a specific symbol (which resides in the data segment), take a look at jmprel. It is a dict (symbol-&gt; GOT addr):</p>
<p>Whether you are after a PLT or GOT entry depends on the architecture. Architecture specific stuff is defined in a class in the Archinfo repository. The way we deal with absolute addresses of functions depending on the architecture is defined in this class, in the got_section_name property.</p>
<p>For more details about ELF loading and architecture specific details, check the <a href="http://www.cs.northwestern.edu/~pdinda/icsclass/doc/elf.pdf" _target="blank">Executable and linkable format document</a> as well as the ABI supplements for each architecture (<a href="http://math-atlas.sourceforge.net/devel/assembly/mipsabi32.pdf" _target="blank">MIPS</a>, <a href="http://math-atlas.sourceforge.net/devel/assembly/PPC-elf64abi-1.7.pdf" _target="blank">PPC64</a>, <a href="http://www.x86-64.org/documentation/abi.pdf" _target="blank">AMD64</a>)..</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>rel = b.loader.main_bin.jmprel
</code></pre>
<h3 id="symbolic-analysis-function-summaries">Symbolic analysis: function summaries</h3>
<p>By default, Project tries to replace external calls to libraries&apos; functions by using <a href="todo.md">symbolic summaries</a> termed <em>SimProcedures</em> (these are summaries of how functions affect the state). </p>
<p>When no such summary is available for a given function:</p>
<ul>
<li>if <code>auto_load_libs</code> is <code>True</code> (this is the default), then the <em>real</em> library function is executed instead. This may or may not be what you want, depending on the actual function. For example, some of libc&apos;s functions are extremely complex to analyze and will most likely cause an explosion of the number of states for the <a href="paths.html">path</a> trying to execute them.</li>
<li>if <code>auto_load_libs</code> is <code>False</code>, then external functions are unresolved, and Project will resolve them to a generic &quot;stub&quot; SimProcedure called <code>ReturnUnconstrained</code>. It does what its name says: it returns unconstrained values.</li>
<li>if <code>use_sim_procedures</code> (this is a parameter to <code>angr.Project</code>, not <code>cle.Loader</code>) is <code>False</code> (it is <code>True</code> by default), then no SimProcedures besides <code>ReturnUnconstrained</code> will be used.</li>
<li>you may specify specific symbols to exclude from being replaced with SimProcedures with the parameters to <code>angr.Project</code>: <code>exclude_sim_procedures_list</code> and <code>exclude_sim_procedures_func</code>.</li>
<li>Look at the code for <code>angr.Project._use_sim_procedures</code> for the exact algorithm.</li>
</ul>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="toplevel.html" class="navigation navigation-prev " aria-label="Previous page: トップレベルインターフェイス">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="ir.html" class="navigation navigation-next " aria-label="Next page: 中間表現">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"バイナリのロード","level":"1.3","depth":1,"next":{"title":"中間表現","level":"1.4","depth":1,"path":"docs/ir.md","ref":"docs/ir.md","articles":[]},"previous":{"title":"トップレベルインターフェイス","level":"1.2","depth":1,"path":"docs/toplevel.md","ref":"docs/toplevel.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"docs/loading.md","mtime":"2016-09-25T13:21:13.652Z","type":"markdown"},"gitbook":{"version":"3.0.0","time":"2016-09-28T03:18:21.902Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/buttons.js"></script>
        
    

    </body>
</html>

